from medperf import config
from medperf.commands.association.priority import AssociationPriority
from medperf.entities.cube import Cube
from medperf.entities.benchmark import Benchmark
from medperf.utils import dict_pretty_print, pretty_error, approval_prompt
from medperf.commands.compatibility_test import CompatibilityTestExecution


class AssociateCube:
    @classmethod
    def run(
        cls,
        cube_uid: str,
        benchmark_uid: int,
        approved=False,
        force_test=False,
        priority=-1,
    ):
        """Associates a cube with a given benchmark

        Args:
            cube_uid (str): UID of model MLCube
            benchmark_uid (int): UID of benchmark
            approved (bool): Skip validation step. Defualts to False
            priority (int): priority of the cube. defaults to -1 (least priority)
                            This number will be ignored by the server if the initiator
                            is not the benchmark owner.
        """
        comms = config.comms
        ui = config.ui
        cube = Cube.get(cube_uid)
        benchmark = Benchmark.get(benchmark_uid)

        _, _, _, result = CompatibilityTestExecution.run(
            benchmark_uid, model=cube_uid, force_test=force_test
        )
        ui.print("These are the results generated by the compatibility test. ")
        ui.print("This will be sent along the association request.")
        ui.print("They will not be part of the benchmark.")
        dict_pretty_print(result.results)

        msg = "Please confirm that you would like to associate "
        msg += f"the MLCube '{cube.name}' with the benchmark '{benchmark.name}' [Y/n]"
        approved = approved or approval_prompt(msg)
        if approved:
            ui.print("Generating mlcube benchmark association")
            metadata = {"test_result": result.results}
            float_priority = AssociationPriority(benchmark_uid, cube_uid, priority)
            float_priority.validate()
            float_priority.convert_priority_to_float()
            float_priority.prevent_underflow()
            # TODO
            comms.associate_cube(cube_uid, benchmark_uid, metadata, float_priority)
        else:
            pretty_error(
                "MLCube association operation cancelled", add_instructions=False
            )
